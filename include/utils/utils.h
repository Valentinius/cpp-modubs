#ifndef UNTITLED1_INCLUDE_UTILS_H_
#define UNTITLED1_INCLUDE_UTILS_H_

#include <cstdint>

namespace modbus {
  /**
   * В пределах данного пространства имен объявлены основные перечисления
   * для использования библиотеки
   */
  namespace enums {
    /**
     * Перечисление, характеризующее статус объект ModbusRequest (запроса MODBUS).
     * С помошью него отслеживается текущее состояние запроса, а так же ошибки, возникающие
     * на транспортном уровне.
     */
    enum RequestStatus {
      /**
       * Статус, который присваивается запроу после его создания
       * и действует до того, как запрос был отправлен в физическое устройство.
       */
      NOT_SENT,
      /**
       * Статус, который присваивается после отправки запроса в физическое устройство
       * и действует до того как либо был получен ответ, либо ответа не было получено
       * за указанный таймаут.
       */
      SENT,
      /**
       * Статус, присваивающийся запросу после того, как был получен корректный ответ
       * от физического устройства.
       */
      SUCCESSFULLY_RESPONSED,
      /**
       * Статус, присваивающийся запросу в случае, если ответ от физического устройства
       * был получен, но не является корректным (например, не совпадает контрольная сумма)
       */
      INCORRECTLY_RESPONSED,
      /**
       * Статус, присваивающийся запросу в случае, если после отправки запроса по
       * истечению определенного таймаута не было получено никакого ответа от физического устройства
       */
      TIMEOUT_ERROR,
      /**
       * Статус, присваивающийся запросу в случае, если по объекту запроса нельзя
       * составить корректный буфер для отправки в физическое устройство
       */
      INCORRECT_REQUEST
    };

    /**
     * Перечисление, характеризующее приоритет запроса к MODBUS в пределах сессии
     */
    enum RequestPriority {
      /**
       * Самый высокий приоритет. Используется чаще всего, когда необходима наиболее быстрая запись
       * (например, для выключения или включения блока питания или других случаев подобного рода)
       */
      IMMEDIATE_WRITE,
      /**
       * Самый высокий приоритет для чтения. Используется тогда, когда необходимо быстро обновить статусы,
       * не дожидаясь обычной записи или чтения, которые были запланированы для устройства зараннее
       */
      IMMEDIATE_READ,
      /**
       * Стандартный приоритет для записи. Используется тогда, когда необходимо обновить какие-либо статусы
       * устройства, но это не требует особой срочности
       */
      WRITE,
      /**
       * Стандартный приоритет для чтения. Используется тогда, когда необходимо получить какие-либо статусы
       * устройства, но это не требует особой срочности
       */
      READ,
      /**
       * Приоритет, использующийся для второстепенных запросов на чтение. Например, периодического чтения статусов
       * какого-либо устройства. Создан для того, чтобы периодические чтения не забивали очередь и не блокировали
       * другие более важные запросы к устройству
       */
      LAZY_READ
    };

    /**
     * Перечисление, характеризующее тип объекта запроса (уровень более высокий, чем функции MODBUS)
     */
    enum RequestType {
      /**
       * Значение, использующееся тогда, когда необходимо записать значение в какой-либо один регистр
       */
      SINGLE_REGISTER_WRITE,
      /**
       * Значение, использующееся тогда, когда необходимо записать значение в несколько регистров. Например,
       * msb и lsb части в два разных регистра для хранения int32
       */
      MULTIPLE_REGISTERS_WRITE,
      /**
       * Значение, использующееся тогда, когда необходимо записать какой-либо бит одного регистра
       */
      PARTIAL_REGISTER_WRITE,
      /**
       * Значение, использующееся тогда, когда необходимо прочитать значение из какого-либо одного регистра
       */
      SINGLE_REGISTER_READ,
      /**
       * Значение, использующееся тогда, когда необходимо прочитать значение из нескольких регистров. Например,
       * msb и lsb части в два разных регистра для хранения int32
       */
      MULTIPLE_REGISTERS_READ,
      /**
       * Значение, использующееся тогда, когда необходимо прочитать какой-либо бит одного регистра
       */
      PARTIAL_REGISTER_READ
    };

    /**
     * Перечисление, характеризующая тип объекта, отвечающего за сборку пакета MODBUS
     */
    enum ModbusFramerType {
      /**
       * Тип для сборки пакета по протоколу Modbus RTU
       */
      RTU = 0,
      /**
       * Тип для сборки пакета по протоколу Modbus ASCII
       */
      ASCII = 1,
      /**
       * Тип для сборки пакета по протоколу Modbus TCP
       */
      TCP = 2
    };

    /**
     * Перечление, характеризующее тип регистров MODBUS
     */
    enum RegisterType {
      /**
       * Coil регистры. 1-битовые регистры на чтение и запись.
       * Номера регистров 1-9999
       */
      COILS,
      /**
       * Discrete input регистры. 1-битовые регистры только на чтение.
       * Номера регистров 10001-19999
       */
      DISCRETE_INPUTS,
      /**
       * Holding регистры. 16-битовые регистры на чтение и запись.
       * Номера регистров 30001-39999
       */
      HOLDING_REGISTERS,
      /**
       * Input регистры. 16-битовые регистры только на чтение.
       * Номера регистров 40001-49999
       */
      INPUT_REGISTERS
    };

    /**
     * Перечисление, характеризующее функции MODBUS (по протоколу)
     */
    enum ModbusFunction {
      /**
       * Чтение группы discrete input регистров (в частном случае - одного)
       */
      READ_DISCRETE_INPUTS_GROUP = 0x02,
      /**
       * Чтение группы coil регистров (в частном случае - одного)
       */
      READ_COILS_GROUP = 0x01,
      /**
       * Чтение группы input регистров (в частном случае - одного)
       */
      READ_INPUTS_GROUP = 0x04,
      /**
       * Чтение группы holding регистров (в частном случае - одного)
       */
      READ_HOLDING_REGISTERS_GROUP = 0x03,
      /**
       * Запись значения в один coil регистр
       */
      WRITE_COILS_ONE = 0x05,
      /**
       * Запись значений в группу coil регистров
       */
      WRITE_COILS_GROUP = 0x0F,
      /**
       * Запись значения в один holding регистр
       */
      WRITE_HOLDING_REGISTERS_ONE = 0x06,
      /**
       * Запись значений в группу holding регистров
       */
      WRITE_HOLDING_REGISTERS_GROUP = 0x10
    };

    /**
     * Перечисление, характеризующее возможные типы ошибок,
     * которые могут возникнуть в ходе отправки или обработки modbus запроса.
     */
    enum ModbusError {
      /**
       * Ошибок не возникло
       */
      NO_ERROR = 0x0,
      /**
       * Принятый код функции не может быть обработан.
       */
      ILLEGAL_FUNCTION = 0x01,
      /**
       * Адрес данных, указанный в запросе, недоступен.
       */
      ILLEGAL_DATA_ADDRESS = 0x02,
      /**
       * Значение, содержащееся в поле данных запроса, является недопустимой величиной
       */
      ILLEGAL_DATA_VALUE = 0x03,
      /**
       * Невосстанавливаемая ошибка имела место, пока ведомое устройство пыталось
       * выполнить затребованное действие
       */
      SLAVE_DEVICE_FAILURE = 0x04,
      /**
       * Ведомое устройство приняло запрос и обрабатывает его, но это требует много времени.
       * Этот ответ предохраняет ведущее устройство от генерации ошибки тайм-аута.
       */
      ACKNOWLEDGE = 0x05,
      /**
       * Ведомое устройство занято обработкой команды. Ведущее устройство должно
       * повторить сообщение позже, когда ведомое освободится
       */
      SLAVE_DEVICE_BUSY = 0x06,
      /**
       * Ведомое устройство не может выполнить программную функцию, заданную в запросе.
       * Этот код возвращается для неуспешного программного запроса, использующего функции
       * с номерами 13 или 14. Ведущее устройство должно запросить диагностическую информацию
       * или информацию об ошибках от ведомого
       */
      NEGATIVE_ACKNOWLEDGE = 0x07,
      /**
       * Ведомое устройство при чтении расширенной памяти обнаружило ошибку паритета.
       * Ведущее устройство может повторить запрос, но обычно в таких случаях требуется ремонт
       */
      MEMORY_PARITY_ERROR = 0x08,
      /**
       * Шлюз неправильно настроен или перегружен запросами
       */
      GATEWAY_PATH_UNAVAILABLE = 0x0A,
      /**
       * Slave устройства нет в сети или от него нет ответа
       */
      GATEWAY_TARGET_DEVICE_FAILED_TO_RESPONSE = 0x0B
    };
  }

  /**
   * Пространство имен, содержащее функции, реализация которых (с точки зрения архитектуры и оптимизации)
   * выгода в отдельности от классов.
   */
  namespace utils {
    /**
     * Функция для расчета контрольной суммы для Modbus RTU пакета.
     * @param data - пакет (без контрольной суммы в конце
     * @param size - размер пакета (без учета контрольной суммы в конце)
     * @param msb - старший байт контрольной суммы
     * @param lsb - младший байт контрольной суммы
     */
    void crcRTU(const uint8_t *data, uint8_t size, uint8_t &msb, uint8_t &lsb);

    /**
     * Метод для разбиения 16-битного значения на старший и младший байты
     * @param data - исходное значения
     * @param lsb - младший байт исходного значения
     * @param msb - старший байт исходного значения
     */
    void toMsbLsb(uint16_t data, uint8_t &lsb, uint8_t &msb);
  /**
   * Метод для разбиения 32-битного значения на старшие и младшие 16-бит
   * @param data - исходное значения
   * @param lsb - младшие 16-бит исходного значения
   * @param msb - старшие 16-бит исходного значения
   */
    void toMsbLsb(uint32_t data, uint16_t &lsb, uint16_t &msb);

    /**
     * Метод для сбора старшего и младшего байта в одно 16-битное число
     * @param lsb - младший байт исходного числа
     * @param msb - старший байт исходного числа
     * @param data - итоговое число в одной переменной
     */
    void fromMsbLsb(uint8_t lsb, uint8_t msb, uint16_t &data);
    /**
     * Метод для сбора старших и младших 16 бит в одно 32-битное число
     * @param lsb - младшие 16-бит исходного числа
     * @param msb - старшие 16-бит исходного числа
     * @param data - итоговое число в одной переменной
     */
    void fromMsbLsb(uint16_t lsb, uint16_t msb, uint32_t &data);


  }
}
#endif //UNTITLED1_INCLUDE_UTILS_H_
